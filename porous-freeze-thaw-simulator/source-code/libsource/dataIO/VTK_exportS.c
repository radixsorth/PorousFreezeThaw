/***********************************************\
* VTK format export module                      *
* selector function version                     *
* (C) 2005-2007 Pavel Strachota			*
* file: VTK_exportS.c                           *
\***********************************************/
#include "common.h"
#include "dataIO.h"

#include <stdio.h>

static _conststring_ header =	"# vtk DataFile Version 2.0\n"
				"%s (generated by VTK_exportS (C) 2005 Pavel Strachota)\n"
				"ASCII\n"
				"DATASET STRUCTURED_POINTS\n";

static _conststring_ VTK_type_names[] = { "int", "float", "float" };

int VTK_exportS(SCALAR_DATA (* data)(int),SCALAR_TYPE type,int x_dim,int y_dim,int z_dim,int values_per_line,_conststring_ comment,_conststring_ path)
/*
exports the data of given type to the VTK compatible STRUCTURED_POINTS format

this version uses the selector function 'data()' which should return a SCALAR_DATA union where the i-th value to be exported
is stored. Here 'i' denotes the integer argument passed to 'data()' which specifies the ordinal number of the processed
data element (value) (i goes from 0 to x_dim*y_dim-1). The appropriate member of the union read by VTK_exportS() (and thus
the appropriate type of the actually exported data) is determined by the 'type' parameter.

return codes:
0	success
-1	file access error
-2	invalid input data
-5	disk full (write error)
*/
{
	FILE * outfile;

	int wrt_stat;

	/* origin */
	double x_or = 0.5;
	double y_or = 0.5;
	double z_or = 0.5;

	/* spacing */
	double x_sp = (double)1/x_dim;
	double y_sp = (double)1/y_dim;
	double z_sp = (double)1/z_dim;

	/* total point data */
	int point_data = x_dim*y_dim*z_dim;
	int i;

	if(point_data==0 || data==NULL) return(-2);

	outfile=fopen(path,"w");
	if(!outfile) return(-1);

	fprintf(outfile,header,comment);			/* write header */


	fprintf(outfile,"DIMENSIONS	%d	%d	%d\n",x_dim,y_dim,z_dim);
	fprintf(outfile,"ORIGIN		%g	%g	%g\n",x_or,y_or,z_or);
	fprintf(outfile,"SPACING		%g	%g	%g\n",x_sp,y_sp,z_sp);
	fprintf(outfile,"POINT_DATA	%d\n",point_data);
	fprintf(outfile,"SCALARS		scalars %s\n",VTK_type_names[type]);
	fprintf(outfile,"LOOKUP_TABLE	default\n\n");

	/* only point_data-1 values will be output in the loop,
	the last one will be output alone, followed by '\n' */

	switch(type) {
		case SCALAR_int:
				for(i=1;i<point_data;i++)
					fprintf(outfile,"%6d%s",data(i-1).int_data,(i%values_per_line)?"	":"\n");
				wrt_stat=fprintf(outfile,"%6d\n",data(i-1).int_data);
				break;
		case SCALAR_FLOAT:
				for(i=1;i<point_data;i++)
					fprintf(outfile,"%*.*" FTC_g "%s",export_fp_precision+3,export_fp_precision,data(i-1).FLOAT_data,(i%values_per_line)?"	":"\n");
				wrt_stat=fprintf(outfile,"%*.*" FTC_g "\n",export_fp_precision+3,export_fp_precision,data(i-1).FLOAT_data);
				break;
		case SCALAR_double:
				for(i=1;i<point_data;i++)
					fprintf(outfile,"%*.*g%s",export_fp_precision+3,export_fp_precision,data(i-1).double_data,(i%values_per_line)?"	":"\n");
				wrt_stat=fprintf(outfile,"%*.*g\n",export_fp_precision+3,export_fp_precision,data(i-1).double_data);
	}

	/*
	generally, wrt_stat may not be negative even in case of a write error. This is because of so called
	FULL buffering of file streams. We detect the possible write error on the next line.
	*/
	if(wrt_stat>=0) wrt_stat=(fflush(outfile)!=0)?-1:1;
	fclose(outfile);
	return((wrt_stat<0)?-5:0);
}
